<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake</title>
  <style>
    :root{
      --bg: #0b0f14;
      --panel: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #10b981;
      --danger: #ef4444;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
    }

    *{ box-sizing: border-box }
    html,body{ height:100% }
    body{
      margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";
      color:var(--text); background: radial-gradient(1200px 600px at 15% -10%, rgba(16,185,129,.12), transparent 40%),
                          radial-gradient(1200px 600px at 120% 10%, rgba(99,102,241,.10), transparent 40%), var(--bg);
    }

    .wrap{ max-width:1100px; margin:24px auto; padding:0 16px }

    header{
      display:flex; gap:16px; align-items:center; justify-content:space-between;
      background:rgba(17,24,39,.7); border:1px solid rgba(148,163,184,.15);
      backdrop-filter: blur(8px); padding:12px 16px; border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.3px }
    .brand-badge{ width:28px; height:28px; border-radius:8px; display:grid; place-items:center;
      background: linear-gradient(135deg, var(--accent), #22d3ee);
      color:#001b12; font-weight:900; }

    .stats{ display:flex; gap:14px; align-items:center; flex-wrap:wrap; justify-content:center; }
    .stat{ background:#0f172a; border:1px solid rgba(148,163,184,.15); border-radius:12px; padding:8px 12px; min-width:95px; text-align:center }
    .stat .label{ font-size:12px; color:var(--muted) }
    .stat .value{ font-size:18px; font-weight:700 }

    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end }
    button, .btn{
      appearance:none; border:none; outline:none; cursor:pointer; user-select:none;
      padding:10px 14px; border-radius:12px; font-weight:600; background:#0f172a; color:var(--text);
      border:1px solid rgba(148,163,184,.18); transition:.2s transform,.2s opacity,.2s background;
    }
    button:hover{ transform: translateY(-1px) }
    .btn-primary{ background:linear-gradient(180deg,#16a34a,#059669); border-color:rgba(16,185,129,.5) }
    .btn-danger{ background:linear-gradient(180deg,#ef4444,#dc2626); border-color:rgba(239,68,68,.5) }
    .btn-ghost{ background:#0b1220 }

    .layout{ display:grid; grid-template-columns: 1fr 320px; gap:16px; margin-top:16px }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr } }

    .card{ background:rgba(17,24,39,.7); border:1px solid rgba(148,163,184,.15); border-radius:var(--radius); padding:12px; box-shadow:var(--shadow) }

    .canvas-wrap{ position:relative; display:grid; place-items:center; padding:10px }
    canvas{ width:100%; height:auto; border-radius:12px; background:#0a0f18; display:block; border:1px solid rgba(148,163,184,.15) }

    .overlay{ position:absolute; left:12px; bottom:12px; pointer-events:none }
    .badge{ font-size:12px; color:var(--muted); background:#0b1220; border:1px solid rgba(148,163,184,.2); padding:6px 10px; border-radius:999px }

    .side{ display:flex; flex-direction:column; gap:12px }
    .section{ padding:12px; border-radius:12px; background:#0b1220; border:1px solid rgba(148,163,184,.15) }
    .section h3{ margin:0 0 8px; font-size:14px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted) }

    /* Session buttons: symmetrical layout */
    .session-actions{ display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:8px }
    .session-actions .btn{ width:100% }

    .row{ display:flex; align-items:center; gap:10px; margin:10px 0 }
    .row label{ width:140px; font-size:14px; color:#cbd5e1 }
    .row input[type="number"], .row input[type="range"], .row select{
      width:100%; accent-color: var(--accent);
    }
    .row input[type="color"]{ width:40px; height:28px; border-radius:6px; border:none; background:#000; padding:0 }
    .row .val{ min-width:34px; text-align:right; font-feature-settings:"tnum" on,"lnum" on }

    .small{ font-size:12px; color:var(--muted) }

    .toast{ position:fixed; left:50%; transform:translateX(-50%); bottom:16px; background:#111827; border:1px solid rgba(148,163,184,.25); padding:10px 14px; border-radius:999px; opacity:0; pointer-events:none; transition:.3s opacity, .3s transform; box-shadow: var(--shadow) }
    .toast.show{ opacity:1; transform:translate(-50%, -4px) }

    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0b1220; border:1px solid rgba(148,163,184,.25); padding:2px 6px; border-radius:6px; font-size:12px }

    .game-over{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.35); backdrop-filter: blur(2px); border-radius:12px }
    .game-over .inner{ background:#0b1220; border:1px solid rgba(148,163,184,.2); padding:18px; border-radius:12px; text-align:center; max-width:280px }
    .game-over h2{ margin:0 0 8px }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="brand-badge">S</div>
        <div>
          <div style="font-size:16px">Snake</div>
          <div class="small">Google Snake–inspired</div>
        </div>
      </div>

      <div class="stats" role="status" aria-live="polite">
        <div class="stat"><div class="label">Score</div><div id="score" class="value">0</div></div>
        <div class="stat"><div class="label">Best</div><div id="best" class="value">0</div></div>
        <div class="stat"><div class="label">Speed</div><div id="speedLabel" class="value">10 tps</div></div>
      </div>

      <div class="controls">
        <button id="btnStart" class="btn btn-primary" title="Start (Space)">Start</button>
        <button id="btnPause" class="btn" title="Pause (Space)">Pause</button>
        <button id="btnRestart" class="btn btn-ghost" title="Restart (R)">Restart</button>
      </div>
    </header>

    <div class="layout">
      <div class="card canvas-wrap">
        <canvas id="game" width="900" height="900" aria-label="Snake game area" role="img"></canvas>
        <div class="overlay"><span class="badge">Use <span class="kbd">WASD</span> / <span class="kbd">Arrow Keys</span> • <span class="kbd">Space</span> Pause • <span class="kbd">R</span> Restart</span></div>
        <div class="game-over" id="gameOver">
          <div class="inner">
            <h2>Game Over</h2>
            <p class="small" id="overMsg">You bumped into something!</p>
            <div style="display:flex; gap:8px; justify-content:center; margin-top:12px">
              <button id="btnTryAgain" class="btn btn-primary">Try Again</button>
              <button id="btnCloseOver" class="btn">Close</button>
            </div>
          </div>
        </div>
      </div>

      <aside class="side">
        <div class="section">
          <h3>Gameplay</h3>
          <div class="row"><label for="gridW">Grid Width</label><input id="gridW" type="range" min="10" max="40" value="22" /><span class="val" id="gridWVal">22</span></div>
          <div class="row"><label for="gridH">Grid Height</label><input id="gridH" type="range" min="10" max="40" value="22" /><span class="val" id="gridHVal">22</span></div>
          <div class="row"><label for="apples">Apples at once</label><input id="apples" type="range" min="1" max="10" value="1" /><span class="val" id="applesVal">1</span></div>
          <div class="row"><label for="speed">Speed (ticks/s)</label><input id="speed" type="range" min="5" max="25" value="10" /><span class="val" id="speedVal">10</span></div>
          <div class="row"><label for="wrap">Wrap walls</label><input id="wrap" type="checkbox" checked /></div>
          <div class="row"><label for="gridLines">Show grid</label><input id="gridLines" type="checkbox" /></div>
          <div class="row"><label for="rainbow">Rainbow snake</label><input id="rainbow" type="checkbox" /></div>
        </div>

        <div class="section">
          <h3>Colors</h3>
          <div class="row"><label for="snakeColor">Snake</label><input id="snakeColor" type="color" value="#10b981" /></div>
          <div class="row"><label for="appleColor">Apple</label><input id="appleColor" type="color" value="#ef4444" /></div>
          <div class="row"><label for="boardColor">Board</label><input id="boardColor" type="color" value="#07101a" /></div>
        </div>

        <div class="section">
          <h3>Session</h3>
          <div class="session-actions">
            <button id="btnApply" class="btn btn-primary" title="Apply settings & restart">Apply Changes</button>
            <button id="btnResetBest" class="btn btn-danger" title="Clear best score">Reset Best</button>
            <button id="btnDefaults" class="btn" title="Restore default settings">Reset to Defaults</button>
          </div>
          <p class="small" style="margin-top:10px">Settings apply on restart. Best score is saved per ruleset (grid, apples, wrap, speed).</p>
        </div>

        <div class="section">
          <h3>Tips</h3>
          <p class="small">Swipe on mobile to steer. Try increasing apples for chaos mode. Rainbow snake just for vibes ✨.</p>
        </div>
      </aside>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite">Saved</div>

  <script>
    // ===== Utility
    const $ = sel => document.querySelector(sel);
    const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));
    const randInt = (min, max) => Math.floor(Math.random()*(max-min+1))+min;

    // ===== DOM refs
    const canvas = $('#game');
    const ctx = canvas.getContext('2d');
    const scoreEl = $('#score');
    const bestEl = $('#best');
    const speedLabel = $('#speedLabel');
    const over = $('#gameOver');
    const overMsg = $('#overMsg');

    const controls = {
      start: $('#btnStart'), pause: $('#btnPause'), restart: $('#btnRestart'),
      tryAgain: $('#btnTryAgain'), closeOver: $('#btnCloseOver'), apply: $('#btnApply'), resetBest: $('#btnResetBest')
    };

    const inputs = {
      gridW: $('#gridW'), gridH: $('#gridH'), apples: $('#apples'), speed: $('#speed'),
      wrap: $('#wrap'), gridLines: $('#gridLines'), rainbow: $('#rainbow'),
      snakeColor: $('#snakeColor'), appleColor: $('#appleColor'), boardColor: $('#boardColor')
    };

    const labels = {
      gridW: $('#gridWVal'), gridH: $('#gridHVal'), apples: $('#applesVal'), speed: $('#speedVal')
    };

    const toast = $('#toast');

    // ===== Config + State
    const defaultConfig = {
      gridW: 22, gridH: 22,
      apples: 1, speed: 10, wrap: true, gridLines: false, rainbow: false,
      snakeColor: '#10b981', appleColor: '#ef4444', boardColor: '#07101a'
    };

    let cfg = loadConfig();

    let state = {
      running: false, gameOver: false,
      score: 0, best: 0,
      snake: [], dir: {x:1,y:0}, nextDir: {x:1,y:0},
      apples: new Set(),
      lastTime: 0, acc: 0, step: 1/ cfg.speed,
      hue: 0,
    };

    // ===== Persistence
    function loadConfig(){
      const saved = JSON.parse(localStorage.getItem('snake_cfg_v1')||'null');
      const merged = { ...defaultConfig, ...(saved||{}) };
      // hydrate UI
      for(const k of Object.keys(defaultConfig)){
        if(inputs[k]) inputs[k].type==='checkbox' ? inputs[k].checked = merged[k] : inputs[k].value = merged[k];
      }
      labels.gridW.textContent = merged.gridW;
      labels.gridH.textContent = merged.gridH;
      labels.apples.textContent = merged.apples;
      labels.speed.textContent = merged.speed;
      speedLabel.textContent = `${merged.speed} tps`;
      document.documentElement.style.setProperty('--accent', merged.snakeColor);
      return merged;
    }

    function saveConfig(){
      localStorage.setItem('snake_cfg_v1', JSON.stringify(cfg));
      showToast('Settings saved');
    }

    function bestKey(c = cfg){
      return `snake_best_${c.gridW}x${c.gridH}_a${c.apples}_w${c.wrap?1:0}_s${c.speed}`;
    }
    function loadBest(){
      const b = parseInt(localStorage.getItem(bestKey())||'0',10);
      return isNaN(b)?0:b;
    }
    function saveBest(v){ localStorage.setItem(bestKey(), String(v)); }

    // ===== Game Setup
    function initGame(){
      // Canvas scaling for crispness
      resizeCanvas();

      state.score = 0; state.gameOver = false; state.running = false;
      state.dir = {x:1,y:0}; state.nextDir = {x:1,y:0};
      state.snake = [];
      state.apples = new Set();
      state.lastTime = 0; state.acc = 0; state.step = 1/cfg.speed; state.hue = 0;
      scoreEl.textContent = '0';
      state.best = loadBest(); bestEl.textContent = state.best;

      // place snake middle
      const cx = Math.floor(cfg.gridW/2), cy = Math.floor(cfg.gridH/2);
      // snake of length 3 facing right; head at center (body trails left)
      for (let i = 0; i < 3; i++) state.snake.push({ x: cx - i, y: cy });

      // spawn apples
      while(state.apples.size < cfg.apples){
        state.apples.add(posKey(randomEmptyCell()));
      }

      draw(0);
    }

    function applySettings(){
      const prevKey = bestKey(cfg);
      cfg.gridW = +inputs.gridW.value; cfg.gridH = +inputs.gridH.value;
      cfg.apples = +inputs.apples.value; cfg.speed = +inputs.speed.value;
      cfg.wrap = !!inputs.wrap.checked; cfg.gridLines = !!inputs.gridLines.checked; cfg.rainbow = !!inputs.rainbow.checked;
      cfg.snakeColor = inputs.snakeColor.value; cfg.appleColor = inputs.appleColor.value; cfg.boardColor = inputs.boardColor.value;
      document.documentElement.style.setProperty('--accent', cfg.snakeColor);
      labels.gridW.textContent = cfg.gridW; labels.gridH.textContent = cfg.gridH; labels.apples.textContent = cfg.apples; labels.speed.textContent = cfg.speed;
      speedLabel.textContent = `${cfg.speed} tps`;
      saveConfig();
      initGame();
      showToast('Applied & restarted');
      // migrate best display to new key
      state.best = loadBest(); bestEl.textContent = state.best;
    }

    function resetDefaults(){
      // Restore defaults, persist, and restart
      cfg = { ...defaultConfig };
      // Update UI controls
      for(const k of Object.keys(defaultConfig)){
        if(inputs[k]) inputs[k].type==='checkbox' ? inputs[k].checked = cfg[k] : inputs[k].value = cfg[k];
      }
      labels.gridW.textContent = cfg.gridW;
      labels.gridH.textContent = cfg.gridH;
      labels.apples.textContent = cfg.apples;
      labels.speed.textContent = cfg.speed;
      speedLabel.textContent = `${cfg.speed} tps`;
      document.documentElement.style.setProperty('--accent', cfg.snakeColor);
      localStorage.setItem('snake_cfg_v1', JSON.stringify(cfg));
      over.style.display = 'none';
      showToast('Defaults restored');
      initGame();
      // reflect best for the default ruleset
      state.best = loadBest(); bestEl.textContent = state.best;
    }

    function resizeCanvas(){
      // Fit square area while respecting DPI
      const rect = canvas.parentElement.getBoundingClientRect();
      const maxSize = Math.min(rect.width - 20, window.innerHeight - 250, 900);
      const cells = Math.max(cfg.gridW, cfg.gridH);
      const cell = Math.max(8, Math.floor(maxSize / cells));
      const px = Math.max(300, cell * cells);
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = px + 'px';
      canvas.style.height = px + 'px';
      canvas.width = Math.floor(px * dpr);
      canvas.height = Math.floor(px * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    window.addEventListener('resize', ()=>{ resizeCanvas(); draw(0); });

    // ===== Helpers
    // color helpers for adaptive grid lines
    function hexToRgb(hex){
      hex = hex.replace('#','');
      if(hex.length===3){ hex = hex.split('').map(ch=>ch+ch).join(''); }
      const num = parseInt(hex,16);
      return { r: (num>>16)&255, g: (num>>8)&255, b: num&255 };
    }
    function mixRgb(a,b,t){ return { r: Math.round(a.r + (b.r-a.r)*t), g: Math.round(a.g + (b.g-a.g)*t), b: Math.round(a.b + (b.b-a.b)*t) }; }
    function gridStrokeFrom(bgHex){
      const c = hexToRgb(bgHex);
      const L = (0.2126*c.r + 0.7152*c.g + 0.0722*c.b) / 255; // relative luminance-ish
      const target = L < 0.5 ? mixRgb(c,{r:255,g:255,b:255},0.7) : mixRgb(c,{r:0,g:0,b:0},0.7);
      return `rgba(${target.r},${target.g},${target.b},0.28)`;
    }

    function posKey(p){ return `${p.x},${p.y}` }
    function fromKey(k){ const [x,y]=k.split(',').map(Number); return {x,y} }

    function randomEmptyCell(){
      let p; let tries = 0;
      const occupied = new Set(state.snake.map(posKey));
      do{
        p = { x: randInt(0,cfg.gridW-1), y: randInt(0,cfg.gridH-1) };
        tries++;
        if(tries>5000) break; // safety
      } while( occupied.has(posKey(p)) || state.apples.has(posKey(p)) );
      return p;
    }

    function addApple(){
      const p = randomEmptyCell();
      state.apples.add(posKey(p));
    }

    // ===== Game Loop
    function start(){ if(state.gameOver){ initGame(); } state.running = true; requestAnimationFrame(loop); }
    function pause(){ state.running = false; }
    function restart(){ initGame(); start(); }

    function loop(t){
      if(!state.running) return;
      if(!state.lastTime) state.lastTime = t;
      const dt = (t - state.lastTime) / 1000;
      state.lastTime = t;
      state.acc += dt;
      const step = 1/cfg.speed;
      while(state.acc >= step){
        tick(); state.acc -= step;
      }
      draw(dt);
      requestAnimationFrame(loop);
    }

    function tick(){
      // update dir
      state.dir = state.nextDir;
      const head = { ...state.snake[0] };
      head.x += state.dir.x; head.y += state.dir.y;

      // wrap or collide walls
      if(cfg.wrap){
        if(head.x < 0) head.x = cfg.gridW-1; if(head.x >= cfg.gridW) head.x = 0;
        if(head.y < 0) head.y = cfg.gridH-1; if(head.y >= cfg.gridH) head.y = 0;
      } else {
        if(head.x < 0 || head.x >= cfg.gridW || head.y < 0 || head.y >= cfg.gridH){
          return gameOver('You hit the wall.');
        }
      }

      // self collision (ignore last tail cell that will move unless we eat)
      const body = state.snake.slice(0, state.snake.length-1);
      if(body.some(p => p.x===head.x && p.y===head.y)){
        return gameOver('You ran into yourself.');
      }

      state.snake.unshift(head);

      const headKey = posKey(head);
      if(state.apples.has(headKey)){
        state.apples.delete(headKey);
        state.score += 1;
        scoreEl.textContent = state.score;
        if(state.score > state.best){ state.best = state.score; bestEl.textContent = state.best; saveBest(state.best); }
        // keep apples count
        while(state.apples.size < cfg.apples) addApple();
      } else {
        state.snake.pop(); // move forward
      }

      state.hue = (state.hue + 2) % 360;
    }

    function gameOver(reason){
      state.running = false; state.gameOver = true;
      overMsg.textContent = reason;
      over.style.display = 'flex';
    }

    // ===== Rendering
    function draw(){
      // compute cell size
      const cssW = parseFloat(getComputedStyle(canvas).width);
      const cssH = parseFloat(getComputedStyle(canvas).height);
      const s = { width: cssW, height: cssH };
      const cell = Math.floor(Math.min(s.width/cfg.gridW, s.height/cfg.gridH));
      ctx.imageSmoothingEnabled = false;

      // clear board
      ctx.fillStyle = cfg.boardColor;
      ctx.fillRect(0,0, s.width, s.height);

      // draw subtle vignette
      ctx.save();
      const grd = ctx.createRadialGradient(s.width*0.5, s.height*0.5, s.width*0.2, s.width*0.5, s.height*0.5, s.width*0.8);
      grd.addColorStop(0, 'rgba(255,255,255,0)');
      grd.addColorStop(1, 'rgba(0,0,0,0.25)');
      ctx.fillStyle = grd; ctx.fillRect(0,0,s.width,s.height); ctx.restore();

      // grid lines
      if(cfg.gridLines){
        ctx.strokeStyle = gridStrokeFrom(cfg.boardColor);
        ctx.lineWidth = 1;
        for(let x=0;x<=cfg.gridW;x++){
          ctx.beginPath(); ctx.moveTo(x*cell+.5, 0); ctx.lineTo(x*cell+.5, cfg.gridH*cell); ctx.stroke();
        }
        for(let y=0;y<=cfg.gridH;y++){
          ctx.beginPath(); ctx.moveTo(0, y*cell+.5); ctx.lineTo(cfg.gridW*cell, y*cell+.5); ctx.stroke();
        }
      }

      // apples
      for(const k of state.apples){
        const p = fromKey(k);
        const x = p.x*cell; const y = p.y*cell; const pad = Math.floor(cell*0.15);
        const r = Math.floor(cell*0.2);
        // apple body
        roundRect(ctx, x+pad, y+pad, cell-pad*2, cell-pad*2, 6);
        ctx.fillStyle = cfg.appleColor; ctx.fill();
        // shine
        ctx.beginPath(); ctx.arc(x+pad+Math.floor(cell*0.25), y+pad+Math.floor(cell*0.25), r, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,.22)'; ctx.fill();
      }

      // snake
      for(let i=state.snake.length-1;i>=0;i--){
        const p = state.snake[i];
        const x = p.x*cell; const y = p.y*cell; const pad = Math.floor(cell*0.12);
        roundRect(ctx, x+pad, y+pad, cell-pad*2, cell-pad*2, 6);
        if(cfg.rainbow){ ctx.fillStyle = `hsl(${(state.hue + i*10)%360} 80% 55%)`; }
        else ctx.fillStyle = cfg.snakeColor;
        ctx.fill();
      }

      // eyes on head
      const head = state.snake[0];
      if(head){
        const x = head.x*cell; const y = head.y*cell; const e = Math.max(2, Math.floor(cell*0.12));
        ctx.fillStyle = '#0b0f14';
        if(state.dir.x !== 0){ // horizontal
          ctx.fillRect(x + (state.dir.x>0? cell*0.65 : cell*0.25), y + cell*0.3, e, e);
          ctx.fillRect(x + (state.dir.x>0? cell*0.65 : cell*0.25), y + cell*0.6, e, e);
        } else { // vertical
          ctx.fillRect(x + cell*0.3, y + (state.dir.y>0? cell*0.65 : cell*0.25), e, e);
          ctx.fillRect(x + cell*0.6, y + (state.dir.y>0? cell*0.65 : cell*0.25), e, e);
        }
      }
    }

    function roundRect(ctx, x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // ===== Input
    const dirs = { ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
                   KeyW:{x:0,y:-1}, KeyS:{x:0,y:1}, KeyA:{x:-1,y:0}, KeyD:{x:1,y:0} };
    function canTurn(nd){ return !(state.dir.x + nd.x === 0 && state.dir.y + nd.y === 0); }

    window.addEventListener('keydown', e=>{
      if(dirs[e.code]){ e.preventDefault(); const nd = dirs[e.code]; if(canTurn(nd)) state.nextDir = nd; }
      if(e.code==='Space'){ e.preventDefault(); state.running ? pause() : start(); }
      if(e.code==='KeyR'){ e.preventDefault(); restart(); }
    }, { passive:false });

    // Touch/swipe
    let touchStart=null;
    canvas.addEventListener('touchstart', e=>{ if(e.touches[0]) touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY}; }, {passive:true});
    canvas.addEventListener('touchend', e=>{
      if(!touchStart) return; const t = e.changedTouches[0]; const dx = t.clientX - touchStart.x; const dy = t.clientY - touchStart.y;
      if(Math.hypot(dx,dy) < 24) return; // ignore taps
      if(Math.abs(dx) > Math.abs(dy)){
        const nd = {x: Math.sign(dx), y:0}; if(canTurn(nd)) state.nextDir = nd;
      } else {
        const nd = {x:0, y: Math.sign(dy)}; if(canTurn(nd)) state.nextDir = nd;
      }
      touchStart=null;
    }, {passive:true});

    // Buttons
    controls.start.addEventListener('click', start);
    controls.pause.addEventListener('click', ()=> state.running ? pause() : start());
    controls.restart.addEventListener('click', restart);
    controls.tryAgain.addEventListener('click', ()=>{ over.style.display='none'; restart(); });
    controls.closeOver.addEventListener('click', ()=>{ over.style.display='none'; });
    if(controls.apply) controls.apply.addEventListener('click', applySettings);
    if (controls.resetBest) {
    controls.resetBest.addEventListener('click', () => {
      localStorage.removeItem(bestKey());
      state.best = 0;
      bestEl.textContent = '0';
      showToast('Best cleared for this ruleset');
    });
    }
    controls.defaults = $('#btnDefaults');
    if(controls.defaults) controls.defaults.addEventListener('click', resetDefaults);

    // Live labels
    for(const k of ['gridW','gridH','apples','speed']){
      inputs[k].addEventListener('input', ()=>{
        labels[k].textContent = inputs[k].value;
        if(k==='speed') speedLabel.textContent = `${inputs[k].value} tps`;
      });
    }

    function showToast(text){
      toast.textContent = text; toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> toast.classList.remove('show'), 1300);
    }

    // Kickoff
    initGame();
  </script>
</body>
</html>
